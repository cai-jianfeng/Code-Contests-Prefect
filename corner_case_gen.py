"""
该代码的主要流程是:
1. 设计一个 Prompt 来引导 LLM 生成特定的 corner case;
2. 调用 OpenAI 的 API 生成 corner case;
3. 调用远程的 sandbox API 来验证生成的 corner case 是否正确:
    3.1: 将生成的 corner case 和给定的 solution/incorrect_solution 一起提交到 sandbox;
    3.2: sandbox 会运行给定的 solution/incorrect_solution 并返回结果;
    3.3: 根据 sandbox 返回的结果来判断 corner case 是否正确;
4. 如果
"""

# %% set up
import os
import json
import requests
from tqdm import tqdm
from openai import OpenAI
import openai
from datasets import load_dataset
import ast
from datasets import Dataset
import base64
import random


# 设置 OpenAI API 密钥
# os.environ["OPENAI_API_KEY"] = "sk-JhC2NWrNAARa9lbPA388E4250f5c4aE19eB590967c22F9B9"
# os.environ["OPENAI_API_BASE"] = "https://lonlie.plus7.plus/v1"
# openai.api_base = "https://lonlie.plus7.plus/v1"
API_BASE = "https://lonlie.plus7.plus/v1"
API_KEY="sk-JhC2NWrNAARa9lbPA388E4250f5c4aE19eB590967c22F9B9"

client = OpenAI(base_url=API_BASE, api_key=API_KEY)

PROMPT_TEMPLATE = """
You are an expert in generating corner cases for programming problems.

Given the following problem statement, your tasks are:
1. Carefully read and understand the problem statement.
2. Identify and summarize the constraints of the input data.
3. Analyze the problem to anticipate common mistakes or edge cases that contestants might overlook.
4. Based on your analysis, design and output targeted adversarial corner cases (only provide the input for each case, as the output will be generated by the reference solution).

Problem Statement:
{problem_statement}

Please provide a list of diverse and challenging input cases that are likely to break incorrect solutions or expose subtle bugs. 
**Strictly follow these output requirements:**
- Only output the input for each corner case, and ensure the output is a Python list of strings (`list[str]`), where each string is a complete input case.
- The output must be a single line of valid Python code, containing only the list (e.g., ['input1', 'input2']).
- Do not include any explanations, comments, or extra text before or after the list.
- Do not use ```python``` or any other formatting, just output the pure list.
- If special characters are needed (such as newlines), escape them (e.g., \n should be written as \\n).
- Use spaces or newlines inside the string as required by the problem's input format.
- The output must be directly parsable by `ast.literal_eval()` in Python.

For example: ['5 2\\nAA\\nAB\\nBB\\nBA\\nAZ\\n']
"""

# - **IMPORTANT: Do NOT use any Python expressions, operations, or function calls (like string multiplication '*', concatenation '+', join(), range(), etc.). Only use literal string values.**
# - **IMPORTANT: Write out the full literal string content explicitly. For example, instead of '.' * 50, write out 50 dots literally.**

ADD_PROMPT_TEMPLATE = """
You have previously generated a set of corner cases for the given programming problem and received the following evaluation results:

- Outputs from correct solutions: {correct_results}
- Outputs from incorrect solutions: {incorrect_results}
- Outputs from the canonical solution (only includes results for corner cases that failed when run with the canonical solution): {outputs}

Your tasks are:
1. Based on the above canonical solution results, identify any corner cases that are incorrect (i.e., those that fail when run with the canonical solution) and correct or remove them.
2. Analyze the above results to determine which corner cases effectively distinguish between correct and incorrect solutions, and which do not.
3. For corner cases that are not effective (i.e., do not differentiate correct and incorrect solutions), improve or replace them with new, more adversarial cases. Do not include the ineffective or old versions in your output.
4. For any newly generated corner cases, combine them with all previously effective corner cases, and output the merged list as a Python list of strings (`list[str]`), where each string is a complete input case.
5. The output must be a single line of valid Python code, containing only the merged list (e.g., `['input1', 'input2']`).
6. Do not include any explanations, comments, or extra text before or after the list.
7. The output must be directly parsable by `ast.literal_eval()` in Python.

Please focus on maximizing the adversarial value of the corner cases based on the feedback above.
"""

# 7. **IMPORTANT: Do NOT use any Python expressions, operations, or function calls (like string multiplication '*', concatenation '+', join(), range(), etc.). Only use literal string values.**
# 8. **IMPORTANT: Write out the full literal string content explicitly. For example, instead of '.' * 50, write out 50 dots literally.**

SOLUTION_RESULT_TEMPLATE = """
language: {language},
solution: {solution},
output: {output}
"""

TEST_CASE_RESULT_TEMPLATE = """
passed: {passed},
stdin: {stdin},
stdout: {stdout},
expected_output: {expected_output}
"""

CANONICAL_SOLUTION_TEMPLATE = """
canonical_solution_language: {language}, 
canonical_solution: {solution},
output: {output}
"""

TEMPLATE = """
Here is a {language} solution to the problem: 
```{language}
{solution}
```
"""
LANGUAGE = ["UNKNOWN_LANGUAGE", "PYTHON", "CPP", "PYTHON3", "JAVA"]

# %% define functions
def generate_corner_case(messages, model="gpt-4o", max_tokens=1000):
    """
    使用 OpenAI API 生成 corner case。

    :param messages: 用于生成 corner case 的消息列表。
    :param model: 使用的模型名称，默认为 gpt-4o。
    :param max_tokens: 生成文本的最大长度。
    :return: 生成的 corner case 文本。
    """
    try:
        response = client.chat.completions.create(
            model=model,
            messages=messages,
            max_tokens=max_tokens
        )
    except Exception as e:
        print(f"Error generating corner case: {e}")
        return ""
    
    return response.choices[0].message.content.strip()


def sandbox_call(api_path, json_data):
    """
    调用远程的 sandbox API 来执行代码。
    """
    res = requests.post(
        api_path,
        json=json_data,
    )

    return res.json()

# 读取 codecontests 数据集
def dataset_read(data_path, split):
    data = load_dataset(data_path, split=split)
    data = list(data)
    # 将其转化为 CommonOJ 格式
    format_data = []
    for sample in tqdm(data):
        format_sample = transform_codecontents(sample)
        format_data.append(format_sample)
    return format_data


def transform_codecontents(sample):
    """
    ['name', 'description', 'public_tests', 'private_tests', 'generated_tests', 'source', 'difficulty', 'solutions', 'incorrect_solutions', 'cf_contest_id', 'cf_index', 'cf_points', 'cf_rating', 'cf_tags', 'is_description_translated', 'untranslated_description', 'time_limit', 'memory_limit_bytes', 'input_file', 'output_file'] -> ['id', 'content', 'test', 'labels', 'canonical_solution']
    """
    
    format_sample = {}
    for key, value in sample.items():
        format_sample[key] = value
    format_sample['id'] = "/".join(['Codeforces'] + sample['name'].split('.')[0].split('_'))
    format_sample['content'] = '# ' + sample['name'].split('.')[-1].strip() + '\n\n' + sample['description']
    format_sample['labels'] = {
        "tag": sample['cf_tags'],
        "title": sample['name'].split('.')[-1].strip()
    }
    canonical_solution = {}
    for i in range(len(LANGUAGE)):
        if i in sample['solutions']['language']:
            if "PYTHON" in LANGUAGE[i]:  # 将 PYTHON 和 PYTHON3 统一处理
                canonical_solution['python'] = sample['solutions']['solution'][sample['solutions']['language'].index(i)]
            else:
                canonical_solution[LANGUAGE[i].lower()] = sample['solutions']['solution'][sample['solutions']['language'].index(i)]
        # else:
        #     canonical_solution[LANGUAGE[i].lower()] = None
    
    
    format_sample['canonical_solution'] = canonical_solution

    test_cases = []
    test_cases_trasform(sample['public_tests'], test_cases)
    test_cases_trasform(sample['private_tests'], test_cases)
    test_cases_trasform(sample['generated_tests'], test_cases)

    format_sample['test'] = test_cases
    return format_sample
    

def test_cases_trasform(test_cases, format_test_cases):
    for input_data, output_data in zip(test_cases['input'], test_cases['output']):
        format_test_cases.append({
            'input': {
                'stdin': input_data
            },
            'output': {
                'stdout': output_data
            }
            })
    

def solution_call(config, solutions, api_path, id, dataset_type, flag=False):
    """
    串行调用远程的 sandbox API 来验证生成的 corner case 是否正确，
    并返回使得结果与 flag 相反的结果。
    """
    results = []
    for language_index, solution in zip(solutions['language'], solutions['solution']):
        language = LANGUAGE[language_index]
        if language == "UNKNOWN_LANGUAGE":
            continue
        if "PYTHON" in language:
            language = "PYTHON"
        config_copy = config.copy()
        config_copy['language'] = language.lower()
        completion = TEMPLATE.format(language=language.lower(), solution=solution)
        payload = {
            'dataset': dataset_type,
            'id': id,
            'completion': completion,
            'config': config_copy
        }
        resp = sandbox_call(api_path + "submit", payload)
        # 1. resp.accepted 为 False
        if not resp.get('accepted', False):
            # 2. 调用 checker 程序判断
            checker = config_copy.get('provided_data', {}).get('checker', None)
            assert checker is not None, "Checker is required for validation."
            accepted = True
            for test_case in resp.get('tests', []):
                if not test_case.get('passed', False):
                    # 提取 stdout 和 test case 的 output
                    stdout = test_case['exec_info']['run_result'].get('stdout')
                    expected_output = test_case['test_info']['output'].get('stdout')

                    stdin = test_case['test_info']['input'].get('stdin', '')

                    try:
                        # 直接将字符串编码为 base64
                        stdin_b64 = base64.b64encode(stdin.encode('utf-8')).decode('utf-8')
                        stdout_b64 = base64.b64encode(stdout.encode('utf-8')).decode('utf-8')
                        expected_output_b64 = base64.b64encode(expected_output.encode('utf-8')).decode('utf-8')
                        with open("testlib.h", 'rb') as file:
                            testlib_data_b64 = base64.b64encode(file.read()).decode('utf-8')
                    except Exception as e:
                        print(f"Error encoding base64 for test case {test_case}: {e}")
                        continue

                    files = {
                        "input.txt": stdin_b64,
                        "output.txt": stdout_b64,
                        "answer.txt": expected_output_b64,
                        "testlib.h": testlib_data_b64
                    }

                    # 构造 API 调用的 payload
                    payload = {
                        "code": checker,
                        "language": "cpp",
                        "extra_args": "input.txt output.txt answer.txt",
                        "files": files,
                    }

                    # 调用 sandbox API
                    try:
                        response = sandbox_call(api_path + "run_code", payload)

                        test_case['checker_info'] = response
                        
                    except Exception as e:
                        print(f"Error calling sandbox API for test case {test_case}: {e}")

                    if test_case['checker_info'].get('status') == "Success":
                        if "ok" not in test_case['checker_info']['run_result'].get("stderr", ""):
                            accepted = False
                            break
                    else:  # 整个 solution 代码运行成功，但是 checker 代码失败
                        accepted = False
                        break
            resp['accepted'] = accepted

        # 针对给定的 flag 来保存相反的结果：如果 flag = True，则保留结果为 False 的 resp；如果 flag = False，则保留结果为 True 的 resp（异或逻辑）
        if flag != resp.get('accepted', False):
            results.append({
                'language': language,
                'solution': solution,
                'result': resp
            })
    return results


def single_data_call(sample, api_path, dataset_type="code_contests_test"):
    """
    针对生成的单个数据的 corner case 进行测试，并返回 solutions 和 incorrect_solutions 中判断错误的结果。
    """
    id = sample['id']
    config = {
        'language': None,
        'locale': "en",
        'compile_timeout': 20,
        'run_timeout': 20,
        'dataset_type': "CommonOJDataset",
        'extra': {
            'run_all_cases': True,
        },
    }
    key_list = ['id', 'content', 'test', 'labels', 'checker', 'canonical_solution']
    provided_data = {}
    for key in key_list:
        provided_data[key] = sample[key]
    config['provided_data'] = provided_data
    solutions = sample['solutions']
    incorrect_solutions = sample['incorrect_solutions']

    res = solution_call(config, solutions, api_path, id, dataset_type, flag=True)
    incorrect_res = solution_call(config, incorrect_solutions, api_path, id, dataset_type, flag=False)
    result = {
        'id': id,
        'solution_result': res,
        'incorrect_solution_result': incorrect_res,
    }
    return result


def single_data_generate(sample, api_path, dataset_type="code_contests_test"):
    """
    针对单个数据生成 corner case，并进行测试，再将测试结果反馈进行 corner case 的优化。
    """
    sandbox_run_api_path = api_path + "run_code"
    problem_statement = sample['name'].split('. ')[-1].strip() + '\n\n' + sample['description']
    prompt = PROMPT_TEMPLATE.format(problem_statement=problem_statement)
    messages = [
        {"role": "system", "content": "You are a helpful assistant."},
        {"role": "user", "content": prompt}
    ]
    corner_cases = []
    all_results = []
    for idx in range(3):  # 循环三次
        case_inputs_original = generate_corner_case(messages)
        # if idx == 0 and sample['id'].replace('/', '_') == "Codeforces_1607_C":
        #     case_inputs_original = "['1\\n1000000000\\n', '2\\n-1000000000 -1000000000\\n', '3\\n1000000000 -1000000000 0\\n', '4\\n1000000000 -999999999 5 -999999999\\n', '2\\n5 -999999995\\n', '5\\n-100000000 -100000000 0 100000000 100000000\\n', '2\\n-1 -2\\n', '10\\n0 0 0 0 0 0 0 0 0 -1\\n']"
        # else:
        #     case_inputs_original = generate_corner_case(messages)

        # 将 corner_case 转化为 Python 列表
        case_inputs = None
        try:
            case_inputs = ast.literal_eval(case_inputs_original)
        except (SyntaxError, ValueError) as e:
            print(f"Error parsing corner case with ast.literal_eval: {e}")
            print(f"Generated content: {case_inputs_original}")
            
            # 尝试使用受限的 eval 来处理包含表达式的情况
            try:
                # 创建受限的执行环境，只允许安全的操作
                restricted_globals = {
                    "__builtins__": {},
                    "range": range,
                    "len": len,
                    "str": str,
                    "int": int,
                    "join": str.join,
                }
                restricted_locals = {}
                case_inputs = eval(case_inputs_original, restricted_globals, restricted_locals)
                print(f"Successfully parsed using restricted eval: {len(case_inputs)} cases")
            except Exception as eval_error:
                print(f"Error parsing with restricted eval: {eval_error}")
                print("Skipping this iteration and trying again...")
                continue  # 跳过这次循环，重新生成
        
        if case_inputs is None:
            print("Failed to parse corner cases, skipping this iteration...")
            break
            
        # 验证解析结果是否为字符串列表
        if not isinstance(case_inputs, list):
            print(f"Parsed result is not a list: {type(case_inputs)}")
            break
            
        if not all(isinstance(item, str) for item in case_inputs):
            print("Not all items in the parsed result are strings")
            break

        print(f"Successfully parsed {len(case_inputs)} corner cases")

        # 调用 sandbox API 来生成 corner case 的 output
        corner_cases = []
        corner_cases_error = []
        for i, case_input in enumerate(case_inputs):
            # 优先获取 python，其次 cpp，再次 java，直到运行成功为止
            code_lang_pairs = []
            if 'python' in sample['canonical_solution'] and sample['canonical_solution']['python']:
                code_lang_pairs.append(('python', sample['canonical_solution']['python']))
            if 'cpp' in sample['canonical_solution'] and sample['canonical_solution']['cpp']:
                code_lang_pairs.append(('cpp', sample['canonical_solution']['cpp']))
            if 'java' in sample['canonical_solution'] and sample['canonical_solution']['java']:
                code_lang_pairs.append(('java', sample['canonical_solution']['java']))

            last_error = None
            for language, code in code_lang_pairs:
                payload = {
                    "code": code,
                    "language": language,
                    "stdin": case_input,
                }
                case_response_output = sandbox_call(sandbox_run_api_path, payload)
                if case_response_output.get('status') == "Success":
                    corner_cases.append({
                        "input": {
                            "stdin": case_input,
                        },
                        "output": {
                            "stdout": case_response_output.get('run_result', '').get('stdout', ''),
                        }
                    })
                    break  # 成功则跳出循环
                else:
                    last_error = case_response_output
                    print(f"Error running code for case {i} in {language}: {last_error}")
            else:
                # 如果所有语言都失败，记录最后一次的错误信息
                print(f"Error running code for case {i}: {last_error}")
                compile_result = last_error.get('compile_result') or {}
                run_result = last_error.get('run_result') or {}
                corner_cases_error.append(
                    f"Stdin: {case_input}; "
                    f"Compile error (code {compile_result.get('return_code', '')}): {compile_result.get('stderr', '')}; "
                    f"Runtime error (code {run_result.get('return_code', '')}): {run_result.get('stderr', '')}"
                )

        sample['test'] = corner_cases
        # 调用 sandbox API 来验证 corner case 的正确性
        result = single_data_call(sample, api_path, dataset_type)

        all_results.append({
            'corner_cases': corner_cases,
            'corner_cases_error': corner_cases_error,
            'result': result,
            'case_inputs_original': case_inputs_original,
            'case_inputs': case_inputs,
            'messages': messages
        })
        # 如果 result 中的 solution_result 和 incorrect_solution_result 和 corner_cases_error 都为空，则 break
        if not result['solution_result'] and not result['incorrect_solution_result'] and not corner_cases_error:
            break
        else:
            # 随机采样 result 中的 solution_result 和 incorrect_solution_result 的元素 (采样最多 3 个)
            solution_result = random.sample(result['solution_result'], min(3, len(result['solution_result'])))
            incorrect_solution_result = random.sample(result['incorrect_solution_result'], min(3, len(result['incorrect_solution_result'])))
            solution_results = [SOLUTION_RESULT_TEMPLATE.format(language=res['language'], solution=res['solution'], output=format_test_cases(res['result']['tests'])) for res in solution_result]
            incorrect_solution_results = [SOLUTION_RESULT_TEMPLATE.format(language=res['language'], solution=res['solution'], output=format_test_cases(res['result']['tests'])) for res in incorrect_solution_result]
            canonical_solution_results = CANONICAL_SOLUTION_TEMPLATE.format(
                language=language,
                solution=code,
                output=corner_cases_error)
            
            # 构造新的 prompt
            add_prompt = ADD_PROMPT_TEMPLATE.format(
                correct_results=solution_results,
                incorrect_results=incorrect_solution_results,
                outputs=canonical_solution_results
            )
            messages.append({"role": "assistant", "content": case_inputs_original})
            messages.append({"role": "user", "content": add_prompt})

            solutions = {
                "language": [LANGUAGE.index(res['language']) for res in solution_result],
                "solution": [res['solution'] for res in solution_result]
            }

            incorrect_solutions = {
                "language": [LANGUAGE.index(res['language']) for res in incorrect_solution_result],
                "solution": [res['solution'] for res in incorrect_solution_result]
            }

            sample['solutions'] = solutions
            sample['incorrect_solutions'] = incorrect_solutions
        
    return corner_cases, all_results


def format_test_cases(test_cases):
    test_cases_results = []
    for test_case in test_cases:
        test_case_result = TEST_CASE_RESULT_TEMPLATE.format(
            passed=test_case.get('passed', False),
            stdin=test_case['test_info']['input']['stdin'],
            stdout=test_case['test_info']['output']['stdout'],
            expected_output=test_case['exec_info']['run_result']['stdout']
        )
        test_cases_results.append(test_case_result)
    return test_cases_results


def codecontests_call(dataset, api_path, dataset_type="code_contests_test", results_dir=None):
    """
    
    """
    os.makedirs(results_dir, exist_ok=True)
    new_dataset = []
    max_length = len(dataset)  # 设置最大长度为 dataset 的长度
    for i, sample in enumerate(tqdm(dataset)):
        # 如果 sample['id'] 已经存在于 results_dir 中，则跳过
        if results_dir:
            sample_name = sample['id'].replace('/', '_') + '.json'
            if os.path.exists(os.path.join(results_dir, sample_name)):
                print(f"Sample {sample['id']} already exists in results directory, skipping...")
                continue
        # 如果 i 大于 max_length，则跳过
        if i >= max_length:
            break
        corner_cases, result = single_data_generate(sample=sample, api_path=api_path, dataset_type=dataset_type)
        sample['corner_cases'] = corner_cases
        sample['result'] = result
        new_dataset.append(sample)
        # print(corner_case)
        
        # dataset = Dataset.from_list(new_dataset)
        # if results_path:
        #     dataset.save_to_disk(results_path)
        # 每个 sample 单独保存为一个文件
        if results_dir:
            sample_name = sample['id'].replace('/', '_') + '.json'
            with open(os.path.join(results_dir, sample_name), 'w') as f:
                json.dump(sample, f, indent=4)
# %% main function
if __name__ == "__main__":
    # codecontests_data_path = "/aiarena/gpfs/code_contests"
    # codecontests_data_path = "/aiarena/gpfs/Code-Contests/test/test_dataset"
    codecontests_data_path = "/aiarena/gpfs/Code-Contests-Uni/test/test_dataset_filtered"
    sandbox_api_path = "http://10.244.230.127:8080/"
    # sandbox_api_path = "http://10.244.213.170:8080/"
    dataset_type = "code_contests_test"
    # dataset = dataset_read(codecontests_data_path, "test")
    # dataset = Dataset.from_parquet("/aiarena/gpfs/Code-Contests/test/test_dataset.parquet")
    dataset = Dataset.load_from_disk(codecontests_data_path)

    codecontests_call(dataset, sandbox_api_path, dataset_type, "/aiarena/gpfs/Code-Contests-Ours/test/")
    # sample = dataset[0]
    # # 调用单个数据生成 corner case
    # corner_case, result = single_data_generate(sample=sample, api_path=sandbox_api_path, dataset_type=dataset_type)
    # print(corner_case)

# %%
